# Промпт для исследования интеграции Робокассы

## Контекст проекта

Исследуй документацию Робокассы (https://docs.robokassa.ru/) и подготовь детальный план интеграции для следующего проекта:

### Архитектура проекта

**Backend:** FastAPI (Python 3.11+) + PostgreSQL + SQLAlchemy (async)
**Frontend:** Telegram Bot (aiogram v3)
**Инфраструктура:** Docker Compose (app, bot, worker, db)

### Текущее состояние платежей

В проекте уже есть:

1. **Модель Payment** (SQLAlchemy):
   - `payment_id: UUID` - уникальный ID платежа
   - `user_id: BigInt` - ID пользователя Telegram
   - `tariff_id: UUID` - тариф/пакет проверок
   - `amount: Decimal` - сумма платежа
   - `currency: str` - валюта (RUB)
   - `checks_count: int` - количество проверок в тарифе
   - `payment_method: Enum` - способ оплаты (ROBOKASSA, TELEGRAM_STARS, MANUAL)
   - `status: Enum` - статус (PENDING, COMPLETED, FAILED, CANCELLED)
   - `robokassa_invoice_id: str | None` - ID счета в Робокассе
   - `robokassa_payment_url: str | None` - URL для оплаты

2. **API Endpoint** `/api/v1/payments/create`:
   - Принимает: `user_id`, `tariff_id`, `payment_method`
   - Создает запись Payment со статусом PENDING
   - **Сейчас возвращает заглушку** для `robokassa_payment_url`

3. **API Endpoint** `/api/v1/payments/robokassa/callback`:
   - **Сейчас заглушка** - принимает callback от Робокассы
   - Должен обновлять статус платежа на COMPLETED
   - Начислять `checks_count` на баланс пользователя

4. **Конфигурация** (уже есть в `.env`):
   - `ROBOKASSA_MERCHANT_LOGIN` - логин магазина
   - `ROBOKASSA_PASSWORD_1` - пароль #1 (для формирования ссылки)
   - `ROBOKASSA_PASSWORD_2` - пароль #2 (для проверки callback)
   - `ROBOKASSA_TEST_MODE` - тестовый режим

### Особенности проекта

1. **Telegram Bot интеграция:**
   - Пользователь нажимает кнопку "Купить" в боте
   - Бот вызывает API `/api/v1/payments/create`
   - Получает `robokassa_payment_url`
   - Открывает ссылку в браузере или показывает пользователю

2. **Асинхронная обработка:**
   - FastAPI использует async/await
   - Все операции с БД через async SQLAlchemy
   - Callback должен быть быстрым и надежным

3. **Безопасность:**
   - Обязательна проверка подписи (SignatureValue) в callback
   - Защита от повторной обработки одного платежа
   - Валидация суммы платежа

---

## Что нужно исследовать в документации Робокассы

### 1. Формирование ссылки на оплату

**Найти:**
- Формат URL для перехода на оплату
- Обязательные параметры запроса:
  - `MerchantLogin` (логин магазина)
  - `OutSum` (сумма платежа)
  - `InvId` (номер счета - можно использовать payment_id)
  - `Description` (описание товара)
  - `SignatureValue` (MD5 hash для проверки)
- Дополнительные параметры:
  - `Shp_*` (custom параметры - можно передать user_id, tariff_id)
  - `Culture` (язык интерфейса)
  - `Encoding` (кодировка)
- Формула расчета `SignatureValue` для ссылки
- Разница между тестовым и боевым URL

**Важно:** 
- Нужен пример кода на Python для генерации URL
- Учесть что у нас Decimal для суммы, нужно правильно форматировать

### 2. Обработка callback (Result URL)

**Найти:**
- Формат callback запроса (GET или POST)
- Параметры которые приходят в callback:
  - `OutSum` - сумма платежа
  - `InvId` - номер счета
  - `SignatureValue` - подпись для проверки
  - `Shp_*` - наши custom параметры
- Формула проверки `SignatureValue` в callback (используется Password #2)
- Что делать если callback пришел дважды (идемпотентность)
- Формат ответа который должен вернуть сервер (OK{InvId})
- Обработка ошибок и повторные запросы от Робокассы

**Важно:**
- Callback должен быть быстрым (< 1 сек)
- Обязательна проверка подписи перед обновлением статуса
- Нужно проверить что платеж еще не обработан

### 3. Success URL и Fail URL

**Найти:**
- Что такое Success URL и когда он вызывается
- Что такое Fail URL и когда он вызывается
- Параметры которые приходят в эти URL
- Нужны ли они для нашей интеграции или достаточно Result URL

**Важно:**
- У нас Telegram бот, пользователь может не вернуться на сайт
- Возможно нужно просто редирект на бота или показывать сообщение

### 4. Тестовый режим

**Найти:**
- Как работает тестовый режим
- Тестовые карты для оплаты
- Отличия тестового и боевого режима
- Как переключиться на боевой режим

### 5. Безопасность и лучшие практики

**Найти:**
- Рекомендации по безопасности
- Защита от подделки callback
- Валидация всех параметров
- Логирование платежей
- Обработка edge cases (несовпадение суммы, дубликаты и т.д.)

### 6. Дополнительные возможности (опционально)

**Изучить:**
- API выставления счетов (если нужен более продвинутый вариант)
- Возвраты (refunds) - может понадобиться
- Статусы платежей и их значения
- Уведомления через другие каналы (SMS, Email)

---

## Технические требования для реализации

### Что нужно реализовать:

1. **Функция генерации URL оплаты:**
```python
def generate_robokassa_payment_url(
    payment_id: UUID,
    amount: Decimal,
    description: str,
    user_id: int,
    tariff_id: UUID,
    test_mode: bool = True
) -> str:
    """
    Генерирует URL для оплаты через Робокассу.
    
    Returns:
        URL для перенаправления пользователя на оплату
    """
```

2. **Функция проверки подписи callback:**
```python
def verify_robokassa_signature(
    out_sum: str,
    inv_id: str,
    signature: str,
    password: str  # Password #2
) -> bool:
    """
    Проверяет подпись callback от Робокассы.
    
    Returns:
        True если подпись валидна
    """
```

3. **Обновление endpoint `/api/v1/payments/robokassa/callback`:**
   - Проверка подписи
   - Поиск платежа по InvId
   - Проверка что платеж еще не обработан
   - Проверка суммы
   - Обновление статуса на COMPLETED
   - Начисление проверок на баланс пользователя
   - Возврат правильного ответа для Робокассы

4. **Интеграция в Telegram Bot:**
   - При нажатии "Купить" → создание платежа → получение URL → показ кнопки "Оплатить"
   - Кнопка открывает URL в браузере
   - После оплаты пользователь может вернуться в бот

### Важные моменты:

1. **Формат суммы:**
   - В БД: `Decimal(10, 2)` - например 199.00
   - Для Робокассы: строка с точкой или запятой? Нужно уточнить в документации

2. **InvId (номер счета):**
   - Можно использовать UUID платежа, но Робокасса может требовать числовой формат
   - Или использовать автоинкремент ID из БД
   - Нужно проверить требования

3. **Custom параметры (Shp_*):**
   - Можно передать `Shp_user_id` и `Shp_tariff_id` для удобства
   - Они вернутся в callback и помогут найти платеж

4. **Обработка ошибок:**
   - Что если callback пришел с неверной подписью?
   - Что если платеж уже обработан?
   - Что если сумма не совпадает?
   - Нужны логи для отладки

5. **Асинхронность:**
   - Все операции должны быть async
   - Callback должен быстро отвечать (< 1 сек)
   - Начисление баланса можно сделать в фоне, но ответ отправить сразу

---

## Выходные данные исследования

После изучения документации подготовь:

1. **Детальный план интеграции:**
   - Пошаговый алгоритм создания платежа
   - Алгоритм обработки callback
   - Схема взаимодействия (диаграмма)

2. **Примеры кода:**
   - Функция генерации URL с правильной формулой MD5
   - Функция проверки подписи
   - Полный код обработки callback

3. **Список параметров:**
   - Все обязательные параметры для URL
   - Все параметры в callback
   - Формат и типы данных

4. **Безопасность:**
   - Чек-лист проверок перед обновлением статуса
   - Рекомендации по защите

5. **Тестирование:**
   - Как протестировать в тестовом режиме
   - Какие данные использовать для тестов

6. **Потенциальные проблемы:**
   - Edge cases которые нужно обработать
   - Частые ошибки при интеграции

---

## Дополнительные вопросы для исследования

1. Можно ли использовать UUID в качестве InvId или нужен числовой ID?
2. Как обрабатывать частичные платежи (если такое возможно)?
3. Нужна ли поддержка разных валют или только RUB?
4. Как работает автоматическое уведомление пользователя после оплаты?
5. Есть ли лимиты на количество запросов к API?

---

## Структура ответа

Оформи результат исследования в виде:

1. **Краткое резюме** - основные моменты интеграции
2. **Техническая спецификация** - детали реализации
3. **Примеры кода** - готовые функции для интеграции
4. **Чек-лист внедрения** - что нужно сделать
5. **Тестирование** - как проверить работу

**Важно:** Все примеры кода должны быть совместимы с:
- Python 3.11+
- FastAPI async/await
- SQLAlchemy async
- Существующей структурой проекта

