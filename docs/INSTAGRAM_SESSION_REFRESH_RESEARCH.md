# Промпт для исследования: Автоматическое обновление Instagram Session ID

## Контекст проекта

Это Telegram-бот для анализа взаимных подписок Instagram. Проект использует:
- **Backend**: FastAPI (Python 3.11)
- **Bot**: aiogram v3
- **Database**: PostgreSQL + SQLAlchemy (async)
- **Scraper**: httpx для запросов к Instagram GraphQL API
- **Infrastructure**: Docker Compose

## Проблема

### Текущая ситуация

1. **Ручное управление сессиями**: Администратор должен вручную получать `sessionid` cookie из браузера и обновлять его через API/бот, когда токен истекает.

2. **Прерывание проверок**: Когда Instagram session_id истекает во время выполнения длительной проверки (может занимать 5-15 минут для аккаунтов с тысячами подписчиков), проверка прерывается с ошибкой `401 Unauthorized`.

3. **Потеря данных**: При истечении токена во время проверки:
   - Уже полученные данные (например, 728 из 1663 подписчиков) теряются
   - Пользователь получает ошибку вместо результата
   - Баланс пользователя возвращается, но время потрачено впустую

4. **Неудобство для админа**: Администратор должен постоянно мониторить логи и обновлять токен вручную, что не масштабируется.

### Пример проблемы из логов

```
2026-01-21 12:39:04 - INFO - Check fe22ca63... using session: 48740228...dFmw
2026-01-21 12:39:12 - INFO - Fetching followers for @caspinru (ID: 2015543502)
2026-01-21 12:39:17 - INFO - Fetched 48 edge_followed_by users
...
2026-01-21 12:40:42 - INFO - Fetched 728 edge_followed_by users
2026-01-21 12:40:49 - WARNING - HTTP error on attempt 1: Client error '401 Unauthorized'
2026-01-21 12:40:52 - WARNING - HTTP error on attempt 2: Client error '401 Unauthorized'
2026-01-21 12:40:56 - WARNING - HTTP error on attempt 3: Client error '401 Unauthorized'
2026-01-21 12:40:56 - ERROR - Error fetching connections: Failed after 3 attempts: 401 Unauthorized
```

Сессия истекла после получения 728 подписчиков из ~1663, проверка была прервана.

## Текущая архитектура

### Хранение сессий

**Модель базы данных** (`app/models/models.py`):
```python
class InstagramSession(Base):
    __tablename__ = "instagram_sessions"
    
    id: int (PK)
    session_id: str  # Instagram sessionid cookie
    is_active: bool  # Только одна активная сессия
    is_valid: bool   # Флаг валидности (помечается False при 401)
    created_at: datetime
    last_used_at: datetime | None
    last_verified_at: datetime | None
    notes: str | None
```

**Сервис управления сессиями** (`app/services/session_service.py`):
- `get_active_session_id()` - получение активной валидной сессии из БД
- `save_session_id()` - сохранение новой сессии (деактивирует старые)
- `validate_session_id()` - валидация сессии через тестовый запрос к Instagram API
- `mark_session_invalid()` - пометка сессии как невалидной при 401 ошибке
- `update_session_last_used()` - обновление времени последнего использования

**Приоритет получения сессии** (`app/config.py`):
1. База данных (активная, валидная сессия)
2. In-memory override (установлен через API)
3. .env файл (fallback)

### Использование сессий

**Instagram Scraper** (`app/services/instagram_scraper.py`):
- Принимает `session_id` в конструкторе
- Использует его для всех запросов к Instagram GraphQL API
- При получении `401 Unauthorized` выбрасывает `SessionExpiredError`
- Нет механизма автоматического обновления сессии

**Check Service** (`app/services/check_service.py`):
- Получает сессию один раз в начале обработки проверки (строка 174)
- Передает сессию в `InstagramScraper` при создании
- При `SessionExpiredError`:
  - Помечает сессию как невалидную
  - Уведомляет админа
  - Возвращает баланс пользователю
  - Завершает проверку с ошибкой

**Обработка ошибок**:
```python
except SessionExpiredError as e:
    # Помечаем сессию как невалидную
    await mark_session_invalid(session_id)
    # Уведомляем админа
    await notify_admin_session_error()
    # Возвращаем баланс
    await refund_check_balance(user_id, f"SessionExpired: {target_username}")
    # Завершаем проверку
    await update_check_status(check_id, status=CheckStatusEnum.FAILED, ...)
```

### API для управления сессиями

**Admin API** (`app/api/admin.py`):
- `GET /api/v1/admin/session` - статус текущей сессии
- `POST /api/v1/admin/session` - обновление сессии (вручную)
- `DELETE /api/v1/admin/session` - очистка сессии

**Admin Bot** (`app/bot/handlers/admin.py`):
- `/admin_set_session` - команда для установки сессии через бота

## Требования к решению

### Функциональные требования

1. **Автоматическое обновление сессии**:
   - Система должна автоматически получать новый `sessionid` из Instagram аккаунта
   - Обновление должно происходить до истечения текущей сессии (proactive refresh)
   - Или немедленно при обнаружении истечения (reactive refresh)

2. **Непрерывность работы**:
   - Проверки не должны прерываться из-за истечения токена
   - Если токен истекает во время проверки, система должна:
     - Получить новый токен
     - Продолжить проверку с нового места (resume) или перезапустить с начала
     - Минимизировать потерю уже полученных данных

3. **Прозрачность для пользователя**:
   - Пользователь не должен замечать процесс обновления токена
   - Проверки должны завершаться успешно даже при обновлении токена

4. **Мониторинг и уведомления**:
   - Администратор должен получать уведомления о:
     - Успешном обновлении токена
     - Проблемах с получением нового токена
     - Критических ситуациях (не удалось обновить)

### Технические требования

1. **Безопасность**:
   - Учетные данные Instagram аккаунта должны храниться безопасно
   - Не хранить пароли в открытом виде
   - Использовать переменные окружения или secure vault

2. **Надежность**:
   - Обработка ошибок при получении нового токена
   - Fallback механизмы
   - Retry логика

3. **Производительность**:
   - Обновление токена не должно блокировать другие проверки
   - Минимальное влияние на время выполнения проверок

4. **Совместимость**:
   - Решение должно работать с текущей архитектурой
   - Не ломать существующий функционал
   - Минимальные изменения в существующем коде

## Вопросы для исследования

### 1. Механизмы получения session_id из Instagram

**Вопросы:**
- Какие есть способы автоматически получить `sessionid` cookie из Instagram?
- Можно ли использовать Instagram API (официальный или неофициальный)?
- Можно ли использовать headless браузер (Selenium, Playwright) для автоматического входа?
- Есть ли способы продлить существующую сессию без полного перелогина?
- Какие есть библиотеки/инструменты для работы с Instagram сессиями?

**Исследовать:**
- Instagram Basic Display API
- Instagram Graph API
- Неофициальные API (instagrapi, instaloader и т.д.)
- Selenium/Playwright для автоматизации браузера
- Механизмы refresh token (если доступны)

### 2. Время жизни Instagram session_id

**Вопросы:**
- Сколько времени живет Instagram `sessionid` cookie?
- Зависит ли время жизни от активности аккаунта?
- Можно ли определить, когда токен истечет, до получения 401 ошибки?
- Есть ли признаки приближающегося истечения?

**Исследовать:**
- Документацию Instagram (если доступна)
- Практический опыт разработчиков
- Анализ логов для определения паттернов истечения

### 3. Стратегии обновления

**Вопросы:**
- **Proactive refresh**: Обновлять токен заранее (например, за 1 час до истечения)?
  - Как определить время истечения?
  - Как часто проверять?
  
- **Reactive refresh**: Обновлять при получении 401 ошибки?
  - Как быстро можно получить новый токен?
  - Как продолжить прерванную проверку?
  
- **Hybrid approach**: Комбинация обоих подходов?

**Исследовать:**
- Best practices для refresh token механизмов
- Паттерны для обработки истечения токенов в фоновых задачах
- Механизмы resume для прерванных операций

### 4. Интеграция с текущей архитектурой

**Вопросы:**
- Как интегрировать автоматическое обновление в `InstagramScraper`?
- Нужен ли отдельный сервис/воркер для обновления токенов?
- Как обновлять сессию в базе данных без прерывания активных проверок?
- Как обрабатывать ситуацию, когда несколько проверок используют одну сессию?

**Исследовать:**
- Паттерны для обновления shared resources в async приложениях
- Механизмы координации между воркерами
- Lock механизмы для предотвращения race conditions

### 5. Обработка ошибок и edge cases

**Вопросы:**
- Что делать, если не удалось получить новый токен?
- Как обрабатывать ситуацию, когда Instagram требует 2FA?
- Что делать при блокировке аккаунта?
- Как обрабатывать rate limiting при получении токена?

**Исследовать:**
- Стратегии обработки ошибок при refresh token
- Механизмы уведомлений администратора
- Fallback стратегии

## Ожидаемый результат исследования

### 1. Анализ вариантов решения

Для каждого возможного подхода предоставить:
- **Описание**: Как работает решение
- **Преимущества**: Плюсы подхода
- **Недостатки**: Минусы и ограничения
- **Сложность реализации**: Оценка трудозатрат
- **Риски**: Потенциальные проблемы

### 2. Рекомендуемое решение

Выбрать оптимальный подход с обоснованием:
- Почему этот подход лучше других
- Как он решает все требования
- Какие компромиссы принимаются

### 3. План реализации

Детальный план внедрения, включающий:

**Архитектура:**
- Новые компоненты/сервисы
- Изменения в существующих компонентах
- Схема взаимодействия компонентов

**Изменения в коде:**
- Список файлов для изменения
- Новые файлы для создания
- Изменения в базе данных (миграции)

**Последовательность внедрения:**
- Этапы реализации
- Зависимости между этапами
- Тестирование на каждом этапе

**Конфигурация:**
- Новые переменные окружения
- Настройки для различных режимов работы

### 4. Технические детали

**Для выбранного решения предоставить:**
- Примеры кода для ключевых компонентов
- Схема базы данных (если нужны изменения)
- Диаграмма последовательности операций
- Обработка edge cases

### 5. Риски и митигация

- Список потенциальных рисков
- Стратегии их митигации
- План отката (rollback plan)

## Ограничения и контекст

### Доступные ресурсы

- **Instagram аккаунт**: Есть доступ к аккаунту, от которого можно получить `sessionid`
- **Учетные данные**: Можно хранить username/password или использовать существующую сессию
- **Инфраструктура**: Docker Compose, можно добавить новые сервисы

### Ограничения

- **Instagram ToS**: Решение должно соответствовать Terms of Service Instagram
- **Rate limiting**: Instagram может ограничивать частоту запросов
- **Безопасность**: Нельзя хранить пароли в открытом виде
- **Производительность**: Решение не должно значительно замедлять проверки

### Существующий код

Исследование должно учитывать:
- Текущую структуру проекта
- Существующие паттерны и стиль кода
- Минимальные изменения в существующем функционале
- Обратную совместимость

## Формат ответа

Пожалуйста, предоставьте исследование в следующем формате:

1. **Executive Summary** (1-2 страницы)
   - Краткое описание проблемы
   - Рекомендуемое решение
   - Ключевые выводы

2. **Детальный анализ** (5-10 страниц)
   - Анализ всех вариантов решения
   - Сравнительная таблица
   - Обоснование выбора

3. **План реализации** (3-5 страниц)
   - Архитектура решения
   - Детальный план внедрения
   - Примеры кода

4. **Риски и митигация** (1-2 страницы)
   - Список рисков
   - Стратегии митигации

5. **Приложения**
   - Диаграммы
   - Примеры кода
   - Ссылки на документацию

## Дополнительные вопросы

Если в процессе исследования возникнут вопросы, которые требуют уточнения от команды разработки, пожалуйста, сформулируйте их четко и структурированно.

---

**Цель**: Создать надежное, автоматическое решение для обновления Instagram session_id, которое устранит необходимость ручного вмешательства администратора и предотвратит прерывание проверок из-за истечения токена.
